[["\n        usize_t kentry();\n        uint8_t gdt_page[4096];\n        uint8_t idt_page[4096];\n        void _kentry(){\n            kentry();\n        }\n        // Serial\n        #define PORT 0x3f8   /* COM1 */\n\n        static inline void outb(uint16_t port, uint8_t val)\n        {\n            asm volatile ( \"outb %0, %1\" : : \"a\"(val), \"Nd\"(port) );\n            /* There's an outb %al, $imm8  encoding, for compile-time constant port numbers that fit in 8b.  (N constraint).\n            * Wider immediate constants would be truncated at assemble-time (e.g. \"i\" constraint).\n            * The  outb  %al, %dx  encoding is the only option for all other cases.\n            * %1 expands to %dx because  port  is a uint16_t.  %w1 could be used if we had the port number a wider C type */\n        }\n        static inline uint8_t inb(uint16_t port)\n        {\n            uint8_t ret;\n            asm volatile ( \"inb %1, %0\"\n                        : \"=a\"(ret)\n                        : \"Nd\"(port) );\n            return ret;\n        }\n        void init_serial() {\n            outb(PORT + 1, 0x00);    // Disable all interrupts\n            outb(PORT + 3, 0x80);    // Enable DLAB (set baud rate divisor)\n            outb(PORT + 0, 0x03);    // Set divisor to 3 (lo byte) 38400 baud\n            outb(PORT + 1, 0x00);    //                  (hi byte)\n            outb(PORT + 3, 0x03);    // 8 bits, no parity, one stop bit\n            outb(PORT + 2, 0xC7);    // Enable FIFO, clear them, with 14-byte threshold\n            outb(PORT + 4, 0x0B);    // IRQs enabled, RTS/DSR set\n        }\n\n        int serial_received() {\n            return inb(PORT + 5) & 1;\n        }\n        \n        char read_serial() {\n            while (serial_received() == 0);\n            return inb(PORT);\n        }\n        int is_transmit_empty() {\n            return inb(PORT + 5) & 0x20;\n        }\n        \n        uint64_t write_serial(char a) {\n            while (is_transmit_empty() == 0);\n            outb(PORT,a);\n            return 0;\n        }\n\n    "],[{"iArgumentType":[],"tag":"IRExternFun","iReturnType":"IUInt8","iName":"read_serial"},{"iArgumentType":["IUInt8"],"tag":"IRExternFun","iReturnType":"IUInt64","iName":"write_serial"},{"iStringLiteral":"Hello, Typekernel!","tag":"IRStringLiteral","iName":"t_12"},{"iFuncBody":[{"iSource":"t_0","tag":"IRDeref","iDestR":["IUInt64","t_1"]},{"tag":"IRImm","iUName":["IUInt8","t_2"],"iLiteral":"0"},{"tag":"IRBinary","iOperand2":"t_2","iUName":["IInt8","t_3"],"iOperand1":"t_1","iOperator":"=="},{"iTOperand2":[[{"tag":"IRInvoke","iUName":["IUInt64","t_4"],"iArguments":["t_1"],"iInvokedFun":"write_serial"},{"tag":"IRImm","iUName":["IUInt64","t_5"],"iLiteral":"0"}],["t_5"]],"tag":"IRTernary","iTOperand3":[[{"tag":"IRCast","iUName":["IUInt64","t_6"],"iOperand":"t_0"},{"tag":"IRImm","iUName":["IUInt64","t_7"],"iLiteral":"1"},{"tag":"IRBinary","iOperand2":"t_7","iUName":["IUInt64","t_8"],"iOperand1":"t_6","iOperator":"+"},{"tag":"IRCast","iUName":["IUInt64","t_9"],"iOperand":"t_8"},{"tag":"IRInvoke","iUName":["IUInt64","t_10"],"iArguments":["t_9"],"iInvokedFun":"f_0"}],["t_10"]],"iTOperand1":"t_3","iLName":[["IUInt64","t_11"]]}],"tag":"IRFun","iReturnField":["IUInt64","t_11"],"iArgumentField":[["IUInt64","t_0"]],"iName":"f_0"},{"iFuncBody":[{"tag":"IRInvoke","iUName":["IUInt64","t_13"],"iArguments":["t_12"],"iInvokedFun":"f_0"},{"iFuncBody":[{"tag":"IRInvoke","iUName":["IUInt64","t_14"],"iArguments":[],"iInvokedFun":"f_1"}],"tag":"IRFun","iReturnField":["IUInt64","t_14"],"iArgumentField":[],"iName":"f_1"},{"tag":"IRInvoke","iUName":["IUInt64","t_15"],"iArguments":[],"iInvokedFun":"f_1"},{"tag":"IRImm","iUName":["IUInt64","t_16"],"iLiteral":"0"}],"tag":"IRFun","iReturnField":["IUInt64","t_16"],"iArgumentField":[],"iName":"kmain"},{"iFuncBody":[{"tag":"IRInvoke","iUName":["IUInt64","t_17"],"iArguments":[],"iInvokedFun":"kmain"},{"tag":"IRImm","iUName":["IUInt64","t_18"],"iLiteral":"0"}],"tag":"IRFun","iReturnField":["IUInt64","t_18"],"iArgumentField":[],"iName":"kentry"}]]